import numpy as npfrom PIL import Imageimport randomimport torchfrom torch.utils.data import Datasetimport torchvision.transforms as transformsimport cv2class CenterCrop(object):    def __init__(self,arg):        self.transform = transforms.CenterCrop(arg)    def __call__(self, sample):        img, label = sample        return self.transform(img),self.transform(label)class Resize(object):    def __init__(self,arg):        self.transform_img = transforms.Resize(arg,Image.BILINEAR)        self.transform_label = transforms.Resize(arg,Image.NEAREST)    def __call__(self, sample):        img, label = sample        return self.transform_img(img),self.transform_label(label)class Normalize(object):    def __init__(self,mean,std):        self.transform = transforms.Normalize(mean, std)    def __call__(self, sample):        img, label = sample        return self.transform(img),labelclass ToTensor(object):    def __init__(self):        pass    def __call__(self, sample):        img, label = sample        label = np.array(label)/255        img = np.array(img)        img = (img-img.min())/(img.max()-img.min())        return torch.from_numpy(img.transpose((2, 0, 1))).float(),torch.from_numpy(label.copy()).long()class RandomRescale(object):    def __init__(self,min_ratio=0.5,max_ratio=1.0):        self.min_ratio = min_ratio        self.max_ratio = max_ratio    def __call__(self, sample):        img, label = sample        width, height = img.size        ratio = random.uniform(self.min_ratio,self.max_ratio)        new_width, new_height = int(ratio*width), int(ratio*height)        return img.resize((new_width,new_height)), label.resize((new_width,new_height))class RandomFlip(object):    def __init__(self,p=0.5):        self.p = p    def __call__(self, sample):        img, label = sample        if random.uniform(0,1)>self.p:            return transforms.functional.hflip(img),transforms.functional.hflip(label)        else:            return img, labelclass RandomColor(object):    def __init__(self,brightness=0.2,contrast=0.2,saturation=0.2,hue=0.2):        self.transform = transforms.ColorJitter(brightness,contrast,saturation,hue)    def __call__(self, sample):        img, label = sample        return self.transform(img),labelclass RandomRotation(object):    def __init__(self, degree=[-5,5]):        self.degree = degree    def __call__(self, sample):        img, label = sample        angle = transforms.RandomRotation.get_params(self.degree)        img = transforms.functional.rotate(img, angle,resample = Image.BILINEAR)        label = transforms.functional.rotate(label, angle)        return img, labelclass RandomCrop(object):    def __init__(self,output_size):        self.output_size = output_size    def __call__(self, sample):        img, label = sample        i, j, h, w = transforms.RandomCrop.get_params(            img, output_size=self.output_size)        img = transforms.functional.crop(img, i, j, h, w)        label = transforms.functional.crop(label, i, j, h, w)        return img,labelclass SegCTDataset(Dataset):    """Covid XRay dataset."""    def __init__(self, txt, transforms):        self.IMAGE_LIB = '../Segmen/data/2d_images/'        self.MASK_LIB = '../Segmen/data/2d_masks/'        self.images = np.loadtxt(txt, dtype=str)        self.transform = transforms    def __len__(self):        return len(self.images)    def __getitem__(self, idx):        if torch.is_tensor(idx):            idx = idx.tolist()        image_name = self.images[idx]        img = cv2.imread(self.IMAGE_LIB + image_name, cv2.IMREAD_UNCHANGED).astype("int16").astype('float32')        img = (img - np.min(img)) / (np.max(img) - np.min(img))        img = Image.fromarray(np.uint8(img * 255)).convert('RGB')        label = Image.open(self.MASK_LIB + image_name)        if self.transform:            img, label = self.transform((img, label))        sample = {'img': img,                  'label': label}        return sample